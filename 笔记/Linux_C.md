> # C语言的设计精神是：相信每个C程序员都是高手，不要阻止程序员去干他们需要干的事

# 复习C

## 剪刀石头布的精髓

```C
restult = (man - computer + 4) % 3 - 1;
```

完整代码

```C
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
int main(void)
{
    char gesture[3][10] = {"scissor", "stone", "cloth"};
    int man, computer, result, ret;
    srand(time(NULL));
    while (1)
    {
        computer = rand() % 3;
        printf("\nInput your gesture (0-scissor 1-stone 2-cloth):\n");
        ret = scanf("%d", &man);
        if (ret != 1 || man < 0 || man > 2)
        {
            printf("Invalid input! Please input 0, 1 or 2.\n");
            continue;
        }
        printf("Your gesture: %s\tComputer's gesture: %s\n", gesture[man], gesture[computer]);
        result = (man - computer + 4) % 3 - 1;
        if (result > 0)
            printf("You win!\n");
        else if (result == 0)
            printf("Draw!\n");
        else
            printf("You lose!\n");
    }
    return 0;
}

```

## 较真随机数生成

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
int main()
{
    time_t times;
    srand((unsigned int)time(&times));//取随机数种子
    int l = rand();
    printf("%d",l);
}
```

## linux代码格式化工具indent

使用方法:

```shell
$ indent -kr -i8 main.c
```

$-kr$ 选项表示 $K\&R$ 风格，$-i8$ 表示缩进 8 个空格的长度。如果没有指定$-nut$选项，则每 8 个缩进空格会自动用一个$Tab$代替



## 排序算法

### 插入排序

反复执行该算法的for循环体，执行LEN-1次，就一定能把数组a排好序，而不管数组a的原始数据是什么

时间复杂度  O($n^2$)

```c
void insertion_sort(int a[], int len)
{
    int i, j, key;
    for (j = 1; j < len; ++j)
    {
        key = a[j];
        i = j - 1;
        while (i >= 0 && a[i] > key)
        {
            a[i + 1] = a[i];
            --i;
        }
        a[i + 1] = key;
    }
}
```

### 归并排序

采取分而治之（Divide-and-Conquer）的策略

时间复杂度 O($nlg^n$)

归并排序的步骤如下：

1. Divide: 把长度为n的输入序列分成两个长度为n/2的子序列。
2. Conquer: 对这两个子序列分别采用归并排序。
3. Combine: 将两个排序好的子序列合并成一个最终的排序序列。

```c

```

## 查找算法

### 折半查找

```c
int binarysearch(int number,int a[],int len)
{
    int mid, start = 0, end = len - 1;
    while (start <= end)
    {
        mid = (start + end) / 2;
        if (a[mid] < number)
            start = mid + 1;
        else if (a[mid] > number)
            end = mid - 1;
        else
            return mid;
    }
    return -1;
}
```

## 栈和队列

### 堆栈->深度优先搜索（DFS）

每次取一个相邻的点走下去，一直走到无路可走了再退回来，取另一个相邻的点再走下去。这称为深度优先搜索（DFS，Depth First Search）

#### 解决迷宫问题

```c
int maze[5][5] = { 
    0, 1, 0, 0, 0,
    0, 1, 0, 1, 0,
    0, 0, 0, 0, 0,
    0, 1, 1, 1, 0,
    0, 0, 0, 1, 0,
};
```

它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序**堆栈解决**找出从左上角到右下角的路线

```c

```

### 队列->广度优先搜索

广度优先是一种步步为营的策略，每次都从各个方向探索一步，将前线推进一步，队列中的元素总是由前线的点组成的，可见正是因为队列先进先出的性质使这个算法具有了广度优先的特点

广度优先搜索还有一个特点是可以找到从起点到终点的**最短路径**

#### 解决迷宫问题

```c
int maze[5][5] = { 
    0, 1, 0, 0, 0,
    0, 1, 0, 1, 0,
    0, 0, 0, 0, 0,
    0, 1, 1, 1, 0,
    0, 0, 0, 1, 0,
};
```

它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序**队列解决**找出从左上角到右下角的路线

```c

```

### 环形队列

将上面的队列改为环形队列，复用空间

```C

```

# C语言的本质

## 数据类型

数据类型在32、64位操作系统中,编译器遵循$ILP32|LP64$规范



| 类型      | ILP32 | LP64 |
| --------- | ----- | ---- |
| char      | 8     | 8    |
| short     | 16    | 16   |
| int       | 32    | 32   |
| long      | 32    | 64   |
| long long | 64    | 64   |
| 指针      | 32    | 64   |

$ILP32$这个缩写的意思是$int（I）$、$long（L）$和指针 $P$ 类型都占32位，通常32位计算机的C编译器采用这种规范，$x86$平台的$gcc$也是如此

$LP64$是指$long（L）$和指针占64位，通常64位计算机的C编译器采用这种规范

指针类型的长度总是和计算机的位数一致

## 运算符

$a += 1$相当于$a = a + 1$。但有一点细微的区别，前者对表达式$a$只求值一次，而后者求值两次，如果a是一个复杂的表达式，求值一次和求值两次的效率是不同的，例如$a[i+j] += 1$和$a[i+j] = a[i+j] + 1$。仅仅是效率上的差别吗？对于没有**Side Effect**的表达式，求值一次和求值两次的结果是一样的，但对于有**Side Effect**的表达式则不一定，例如$a[foo()] += 1$和$a[foo()] = a[foo()] + 1$，如果$foo()$函数调用有**Side Effect**，比如会打印一条消息，那么前者只打印一次，而后者打印两次。

$++i$相当于$i = i + 1$，其实更准确地说应该是等价于$i += 1$，而$--i$等价于$i -= 1$。

## 计算器体系结构基础

### CPU

CPU总是周而复始地做同一件事：从内存取指令，然后解释执行它，然后再取下一条指令，再解释执行。

CPU包含以下功能单元：

- 寄存器（**Register**），是**CPU**内部的高速存储器，像内存一样可以存取数据，但比访问内存快得多。**x86**的寄存器如eax、ebp、eip等等，有些寄存器保存的数据只能用于某种特定的用途，比如eip寄存器用作程序计数器，这称为特殊寄存器（**Special-purpose Register**），而另外一些寄存器保存的数据可以用在各种运算和读写内存的指令中，比如eax寄存器，这称为通用寄存器（**General-purpose Register**）。
- 程序计数器（**PC，Program Counter**），保存着**CPU**取指令的地址，每次**CPU**读出程序计数器中保存的地址，然后按这个地址去内存中取指令，这时程序计数器保存的地址会自动加上该指令的长度，指向内存中的下一条指令。
  程序计数器通常是**CPU**的一个特殊寄存器，**x86**的程序计数器是特殊寄存器eip，由于地址是**32**位的，所以这个寄存器也是**32**位的，事实上通用寄存器也是**32**位的，所以也可以说处理器的位数是指它的寄存器的位数。处理器的位数也叫做字长，字（**Word**）这个概念用得比较混乱，在有些上下文中指**16**位，在有些上下文中指**32**位（这种情况下**16**位被称为半字**Half Word**），在有些上下文中指处理器的字长，如果处理器是**32**位那么一个字就是**32**位，如果处理器是**64**位那么一个字就是**64**位。
- 指令解码器（**Instruction Decoder**）。**CPU**取上来的指令由若干个字节组成，这些字节中有些位表示内存地址，有些位表示寄存器编号，有些位表示这种指令做什么操作，是加、减、乘、除还是读、写，指令解码器负责解释这条指令的含义，然后调动相应的执行单元去执行它。
- 算术逻辑单元（**ALU，Arithmetic and Logic Unit**）。如果解码器将一条指令解释为运算指令，就调动算术逻辑单元去做运算，比如加减乘除、位运算、判断一个条件是否成立等。运算结果可能保存在寄存器中，也可能保存到内存中。
- 地址和数据总线（**Bus**）。**CPU**和内存之间用地址总线、数据总线和控制线连接起来，**32**位处理器有**32**条地址线和**32**条数据线，每条线上有**1**和**0**两种状态，**32**条线的状态就可以表示一个**32**位的数。如果在执行指令过程中需要访问内存，比如从内存读一个数到寄存器，则执行过程可以想像成这样：

1. **CPU**内部将寄存器对接到数据总线上，使寄存器的每一位对接到一条数据线，等待接收数据。

2. **CPU**将内存地址通过地址线发给内存，然后通过另外一条控制线发一个读请求。

3. 内存收到地址和读请求之后，将相应的存储单元对接到数据总线的另一端，这样，存储单元每一位的**1**或**0**状态通过一条数据线到达**CPU**寄存器中相应的位，就完成了数据传送。

  往内存里写数据的过程与此类似，只是数据线上的传输方向相反。

### 设备

从**CPU**核引出的地址和数据总线有一端经总线接口引出到芯片引脚上了，还有一端没有引出，而是接到芯片内部集成的设备上，这些设备都有各自的内存地址范围，也可以像访问内存一样访问，很多体系结构（比如**ARM**）采用这种方式操作设备，称为内存映射**I/O（Memory-mapped I/O）**。但是**x86**比较特殊，**x86**对于设备有独立的端口地址空间，**CPU**核需要引出额外的地址线来连接片内设备，访问设备寄存器时用特殊的in/out指令，而不是和访问内存用同样的指令，这种方式称为端口**I/O（Port I/O）**

### MMU

现代操作系统普遍采用虚拟内存管理（**Virtual Memory Management**）机制，这需要**MMU**（**Memory Management Unit**，内存管理单元）的支持。有些嵌入式处理器没有**MMU**，则不能运行依赖于虚拟内存管理的操作系统。

有些**32**位的服务器可以配置大于**4GB**的物理内存。我们说**32**位的**CPU**，是指**CPU**寄存器是**32**位的，数据总线是**32**位的，虚拟地址空间是**32**位的，而物理地址空间则不一定是**32**位的。物理地址的范围是多少，取决于处理器引脚上有多少条地址线，也取决于这些地址线上实际连接了多大的内存芯片

### Memory Hierarchy

由于硬件技术的限制，我们可以制造出容量很小但很快的存储器，也可以制造出容量很大但很慢的存储器，但不可能两边的好处都占着，不可能制造出访问速度又快容量又大的存储器。因此，现代计算机都把存储器分成若干级，称为**Memory Hierarchy**，按照离**CPU**由近到远的顺序依次是**CPU寄存器**、**Cache**、**内存**、**硬盘**，越靠近**CPU**的存储器容量越小但访问速度越快

| 存储器类型 | 位于哪里                                                     | 存储容量                                                     | 半导体工艺                                                   | 访问时间                                             | 如何访问                                                     |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------------------------- | ------------------------------------------------------------ |
| CPU寄存器  | 位于CPU执行单元中。                                          | CPU寄存器通常只有几个到几十个，每个寄存器的容量取决于CPU的字长，所以一共只有几十到几百字节。 | “寄存器”这个名字就是一种数字电路的名字，它由一组触发器（**Flip-flop**）组成，每个触发器保存一个Bit的数据，可以做存取和移位等操作。计算机掉电时寄存器中保存的数据会丢失。 | 寄存器是访问速度最快的存储器，典型的访问时间是几纳秒 | 使用哪个寄存器，如何使用寄存器，这些都是由指令决定的。       |
| Cache      | 和MMU一样位于CPU核中。                                       | **Cache**通常分为几级，最典型的是如上图所示的两级**Cache**，**一级Cache**更靠近CPU执行单元，**二级Cache**更靠近物理内存，通常一级Cache有几十到几百KB，二级Cache有几百KB到几MB。 | Cache和内存都是由**RAM（RandomAccessMemory）**组成的，可以根据地址随机访问，计算机掉电时RAM中保存的数据会丢失。不同的是，Cache通常由**SRAM**（**StaticRAM**，静态RAM）组成，而内存通常由**DRAM**（**DynamicRAM**，动态RAM）组成。**DRAM**电路比**SRAM**简单，存储容量可以做得更大，但**DRAM**的访问速度比**SRAM**慢。 | 典型的访问时间是几十纳秒。                           | Cache缓存最近访问过的内存数据，由于Cache的访问速度是内存的几十倍，所以有效地利用Cache可以大大提高计算机的整体性能。一级Cache是这样工作的：CPU执行单元要访问内存时首先发出**VA**，Cache利用**VA**查找相应的数据有没有被缓存，如果Cache中有就不需要访问物理内存了，是读操作就直接将Cache中的数据传给CPU寄存器，是写操作就直接在Cache中改写数据；如果Cache中没有，就去物理内存中取数据，但并不是要哪个字节就取哪个字节，而是把相邻的几十个字节都取上来缓存着，以备下次用到，这称为一个**Cache Line**，典型的**CacheLine**大小是32~256字节。如果计算机还配置了二级缓存，则在访问物理内存之前先用**PA**去二级缓存中查找。一级缓存是用VA寻址的，二级缓存是用**PA**寻址的，这是它们的区别。Cache所做的工作是由硬件自动完成的，而不是像寄存器一样由指令决定先做什么后做什么。 |
| 内存       | 位于CPU外的芯片，与CPU通过地址和数据总线相连。               | 典型的存储容量是几百MB到几GB。                               | 由DRAM组成，详见上面关于Cache的说明。                        | 典型的访问时间是几百纳秒。                           | 内存是通过地址来访问的，但是在启用MMU的情况下，程序指令中的地址是VA，而访问内存用的是PA，并无直接关系，这种情况下内存的分配和使用由操作系统通过修改MMU的映射项来协调。 |
| 硬盘       | 位于设备总线上，并不直接和CPU相连，CPU通过设备总线的控制器访问硬盘。 | 典型的存储容量是几百GB                                       | 硬盘由磁性介质和磁头组成，访问硬盘时存在机械运动，磁头要移动，磁性介质要旋转，机械运动的速度很难提高到电子的速度，所以访问速度很受限制。但是保存在硬盘上的数据掉电后不会丢失。 | 典型的访问时间是几毫秒，是寄存器的$10^6$倍。         | 由驱动程序操作设备总线控制器去访问。由于硬盘的访问速度较慢，操作系统通常在一次从硬盘上读几个页面（典型值是4KB）到内存中缓存起来，如果这些数据后来都被程序访问到了，那么这一次硬盘访问的时间就可以分摊（Amortize）给多次数据访问了。由驱动程序操作设备总线控制器去访问。由于硬盘的访问速度较慢，操作系统通常在一次从硬盘上读几个页面（典型值是4KB）到内存中缓存起来，如果这些数据后来都被程序访问到了，那么这一次硬盘访问的时间就可以分摊（Amortize）给多次数据访问了。 |

对这个表格总结如下。

- 寄存器、Cache和内存中的数据都是掉电丢失的，这称为易失性存储器（**VolatileMemory**），与之相对的，硬盘是一种非易失性存储器（**Non-volatile Memory**）。
- 除了访问寄存器由程序指令直接控制之外，访问其它存储器都不是由指令直接控制的，有
  些是硬件自动完成的，有些是操作系统配合硬件完成的。
- Cache从内存取数据时一次取一个**Cache Line**缓存起来，操作系统从硬盘取数据时一次取几KB缓存起来，都是希望这些数据以后会被访问到。大多数程序的行为都具有局部性（**Locality**）的特点：它们会花费大量的时间反复执行一小段代码（例如循环），或者反复访问一个很小的地址范围中的数据（例如访问一个数组）。所以预读缓存的办法是很有效的：CPU取一条指令，我把它相邻的指令也都缓存起来，CPU很可能马上就会取到；CPU访问一个数据，我把它相邻的数据也都缓存起来，CPU很可能马上就会访问到。设想有两台计算机，一台有32KB的Cache，另一台没有Cache，而内存都是512MB的，硬盘都是100GB的，虽然多出来32KB的Cache和内存、硬盘的容量相比微不足道，但由于局部性原理，有Cache的计算机明显会快很多。高速存储器即使容量只能做得很小也能显著提升计算机的性能，这就是**Memory Hierarchy**的意义所在。

## x86汇编基础

```assembly
#PURPOSE : Simple program that exits and returns a 
#   status code back to the Linux kernel
#
#INPUT : none
#
#OUTPUT : returns a status code.This can be viewed 
#   by typing
#
#   echo $ ? 
#
#   after running the program
#
#VARIABLES : 
#   % eax holds the system call number 
#   % ebx holds the return status 
#
.section.data
.section.text
.globl 
_start_start : 
    movl $1, % eax  #this is the linux kernel command 
                    #number(system call) for exiting 
                    #a program 
    movl $4, % ebx  #this is the status number we will 
                    #return to the operating system.
                    #Change this around and it will 
                    #return different things to 
                    #echo $ ? 
    int $0x80       #this wakes up the kernel to run 
                    #the exit command
```

把这个程序保存成文件hello.s（汇编程序通常以.s作为文件名后缀），然后用汇编器（**Assembler**）as把汇编程序中的助记符翻译成机器指令，生成目标文件hello.o：

```shell
$ as hello.s -o hello.o
```

然后用链接器（**Linker**，或**Link Editor**）ld把目标文件hello.o链接成可执行文件hello，然后执行：

```shell
$ ld hello.o -o hello
$ ./hello
$ echo $?
4
```

### 解释汇编

程序中的#号表示单行注释，类似于C语言的//注释

```assembly
.section .data
```

汇编程序中以.开头的名称并不是指令的助记符，不会被翻译成机器指令，而是给汇编器一些特殊的指示，称为汇编指示（**Assembler Directive**）或伪操作（**Pseudo-operation**），由于它不是真正的指令所以加个“伪”字。.section指示把代码划分成若干个段（**Section**），程序被操作系统加载执行时，每个段被加载到不同的地址，具有不同的读、写、执行权限。.data段保存程序的数据，是可读可写的，C程序的全局变量也属于.data段。本程序中没有定义数据，所以.data段是空的。

```assembly
.section .text
```

.text段保存代码，是只读和可执行的，后面那些指令都属于这个.text段

```assembly
.globl _start
```

\_start是一个符号（Symbol），符号在汇编程序中代表一个地址，可以用在指令中，汇编程序经过汇编器的处理之后，所有的符号都被替换成它所代表的地址值。在C语言中我们通过变量名访问一个变量，其实就是读写某个地址的内存单元，我们通过函数名调用一个函数，其实就是跳转到该函数第一条指令所在的地址，所以变量名和函数名都是符号，本质上是代表内存地址的。

.globl指示告诉汇编器，_start这个符号要被链接器用到，所以要在目标文件的符号表中给它特殊标记。\_start就像C程序的main函数一样特殊，是整个程序的入口，链接器在链接时会查找目标文件中的\_start符号代表的地址，把它设置为整个程序的入口地址，所以每个汇编程序都要提供一个\_start符号并且用.globl声明。如果一个符号没有用.globl指示声明，就表示这个符号不会被链接器用到。

```assembly
_start:
```

\_start在这里就像C语言的语句标号一样。汇编器在处理汇编程序时会计算每个数据对象和每条指令的地址，当汇编器看到这样一个标号时，就把它下面一条指令的地址作为\_start这个符号所代表的地址。而\_start这个符号又比较特殊，它所代表的地址是整个程序的入口地址，所以下一条指令movl $1, %eax就成了程序中第一条被执行的指令。

```assembly
movl $1, %eax
```

这是一条数据传送指令，CPU内部产生一个数字1，然后传送到eax寄存器中。mov后面的l表示**long**，说明是32位的传送指令。CPU内部产生的数称为立即数（**Immediate**），在汇编程序中，立即数前面要加$，寄存器名前面要加%，以便跟符号名区分开。

```assembly
movl $4, %ebx
```

和上一条指令类似，生成一个立即数4，传送到ebx寄存器中。

```assembly
int $0x80
```

前两条指令都是为这条指令做准备的，执行这条指令时发生以下动作：
1. int指令称为软中断指令，可以用这条指令故意产生一个异常，上一章讲过，异常的处理和中断类似，**CPU**从用户模式切换到特权模式，然后跳转到内核代码中执行异常处理程序。
2. int指令中的立即数**0x80**是一个参数，在异常处理程序中要根据这个参数决定如何处理，在**Linux**内核中，int $0x80这种异常称为系统调用（**System Call**）。内核提供了很多系统服务供用户程序使用，但这些系统服务不能像库函数（比如printf）那样调用，因为在执行用户程序时CPU处于用户模式，不能直接调用内核函数，所以需要通过系统调用切换CPU模式，通过异常处理程序进入内核，用户程序只能通过寄存器传几个参数，之后就要按内核设计好的代码路线走，而不能由用户程序随心所欲，想调哪个内核函数就调哪个内核函数，这样保证了系统服务被安全地调用。在调用结束之后，**CPU**再切换回用户模式，继续执行int指令后面的指令，在用户程序看来就像函数的调用和返回一样。
3. eax和ebx寄存器的值是传递给系统调用的两个参数，eax的值是系统调用号，1表示_exit系统调用，ebx的值则是传给_exit系统调用的参数，也就是退出状态。_exit这个系统调用会终止掉当前进程，而不会返回它继续执行。以后我们会讲到其它系统调用，也是由int $0x80指令引发的，eax的值是系统调用的编号，不同的系统调用需要的参数个数也不同，比如有的需要ebx、ecx、edx三个寄存器的值做参数，大多数系统调用完成之后是会返回用户程序继续执行的，本例的_exit系统调用比较特殊。

**x86**汇编的两种语法：**intel**语法和**AT&T**语法

**x86**汇编一直存在两种不同的语法，在**intel**的官方文档中使用**intel**语法，**Windows**也使用**intel**语法，而**UNIX**平台的汇编器一直使用**AT&T**语法，所以本书使用**AT&T**语法。mov %edx,%eax这条指令如果用**intel**语法来写，就是mov eax,edx，寄存器名不加%号，并且源操作数和目标操作数的位置互换。

### x86的寄存器

**x86**的通用寄存器有eax、ebx、ecx、edx、edi、esi。这些寄存器在大多数指令中是可以任意选用的，比如movl指令可以把一个立即数传送到eax中，也可传送到ebx中。但也有一些指令规定只能用其中某些寄存器做某种用途，例如除法指令idivl要求被除数在eax寄存器中，edx寄存器必须是0，而除数可以在任意寄存器中，计算结果的商数保存在eax寄存器中（覆盖原来的被除数），余数保存在edx寄存器中。也就是说，通用寄存器对于某些指令而言不是通用的。

x86的特殊寄存器有ebp、esp、eip、eflags。eip是程序计数器，eflags保存着计算过程中产生的标志位，包括进位、溢出、零、负数四个标志位，在x86的文档中这几个标志位分别称为**CF、OF、ZF、SF**。ebp和esp用于维护函数调用的栈帧

### 求一组数的最大值的汇编程序

```assembly
#PURPOSE: This program finds the maximum number of a set of data items.
#
#VARIABLES: The registers have the following uses:
#
# %edi - Holds the index of the data item being 
examined
# %ebx - Largest data item found
# %eax - Current data item
#
# The following memory locations are used:
#
# data_items - contains the item data. A 0 is used
# to terminate the data
# 
    .section .data
data_items:                             #These are the data items 
    .long 3,67,34,222,45,75,54,34,44,33,22,11,66,0 
    .section .text 
    .globl _start
_start: 
    movl $0, %edi                       # move 0 into the index 
register 
    movl data_items(,%edi,4), %eax      # load the first byte 
of data 
    movl %eax, %ebx                     # since this is the first 
item, %eax is 
                                        # the biggest
start_loop:                             # start loop 
    cmpl $0, %eax                       # check to see if we've hit the 
end 
    je loop_exit 
    incl %edi                           # load next value 
    movl data_items(,%edi,4), %eax 
    cmpl %ebx, %eax                     # compare values 
    jle start_loop                      # jump to loop beginning if the 
new                                 
                                        # one isn't bigger 
    movl %eax, %ebx                     # move the value as the largest 
    jmp start_loop                      # jump to loop beginning
loop_exit: 
    # %ebx is the status code for the _exit system call 
    # and it already has the maximum number 
    movl $1, %eax                       #1 is the _exit() syscall 
    int $0x80
```

汇编、链接、执行:

```shell
$ as max.s -o max.o
$ ld max.o -o max
$ ./max
$ echo $?
```

## 变量

作用域（**Scope**）这个概念适用于所有标识符，而不仅仅是变量，C语言的作用域分为以下几类：

- 函数作用域（**Function Scope**），标识符在整个函数中都有效。只有语句标号属于函数作用域。标号在函数中不需要先声明后使用，在前面用一个goto语句也可以跳转到后面的某个标号，但仅限于同一个函数之中。
- 文件作用域（**File Scope**），标识符从它声明的位置开始直到这个程序文件的末尾都有效。例如上例中main函数外面的A、a、b、c，还有main也算，printf其实是在stdio.h中声明的，被包含到这个程序文件中了，所以也算文件作用域的。
- 块作用域（**Block Scope**），标识符位于一对{}括号中（函数体或语句块），从它声明的位置开始到右}括号之间有效。例如上例中main函数里的a、b、c。此外，函数定义中的形参也算块作用域的，从声明的位置开始到函数末尾之间有效。
- 函数原型作用域（**Function Prototype Scope**），标识符出现在函数原型中，这个函数原型只是一个声明而不是定义（没有函数体），那么标识符从声明的位置开始到在这个原型末尾之间有效。例如int foo(int a, int b);中的a和b。

对属于同一命名空间（**Name Space**）的重名标识符，内层作用域的标识符将覆盖外层作用域的标识符，例如局部变量名在它的函数中将覆盖重名的全局变量。命名空间可分为以下几类：

- 语句标号单独属于一个命名空间。例如在函数中局部变量和语句标号可以重名，互不影响。由于使用标号的语法和使用其它标识符的语法都不一样，编译器不会把它和别的标识符弄混。
- struct，enum和union（下一节介绍union）的类型**Tag**属于一个命名空间。由于**Tag**前面总是带struct，enum或union关键字，所以编译器不会把它和别的标识符弄混。
- struct和union的成员名属于一个命名空间。由于成员名总是通过.或->运算符来访问而不会单独使用，所以编译器不会把它和别的标识符弄混。
- 所有其它标识符，例如变量名、函数名、宏定义、typedef的类型名、enum成员等等都属于同一个命名空间。如果有重名的话，宏定义覆盖所有其它标识符，因为它在预处理阶段而不是编译阶段处理，除了宏定义之外其它几类标识符按上面所说的规则处理，内层作用域覆盖外层作用域。

标识符的链接属性（**Linkage**）有三种：

- 外部链接（**External Linkage**），如果最终的可执行文件由多个程序文件链接而成，一个标识符在任意程序文件中即使声明多次也都代表同一个变量或函数，则这个标识符具有**External Linkage**。具有**External Linkage**的标识符编译后在符号表中是GLOBAL的符号。例如上例中main函数外面的a和c，main和printf也算。

- 内部链接（**Internal Linkage**），如果一个标识符在某个程序文件中即使声明多次也都代表
  同一个变量或函数，则这个标识符具有**Internal Linkage**。例如上例中main函数外面的b。如果有另一个foo.c程序和main.c链接在一起，在foo.c中也声明一个static int b;，则那个b和这个b不代表同一个变量。具有**Internal Linkage**的标识符编译后在符号表中是LOCAL的符号，但main函数里面那个a不能算**Internal Linkage**的，因为即使在同一个程序文件中，在不同的函数中声明多次，也不代表同一个变量。
- 无链接（**No Linkage**）。除以上情况之外的标识符都属于No Linkage的，例如函数的局部变量，以及不表示变量和函数的其它标识符。

存储类修饰符（Storage Class Specifier）有以下几种关键字，可以修饰变量或函数声明：

- static，用它修饰的变量的存储空间是静态分配的，用它修饰的文件作用域的变量或函数具有**Internal Linkage**。
- auto，用它修饰的变量在函数调用时自动在栈上分配存储空间，函数返回时自动释放，例如上例中main函数里的b其实就是用auto修饰的，只不过auto可以省略不写，auto不能修饰文件作用域的变量。
- register，编译器对于用register修饰的变量会尽可能分配一个专门的寄存器来存储，但如果实在分配不开寄存器，编译器就把它当auto变量处理了，register不能修饰文件作用域的变量。现在一般编译器的优化都做得很好了，它自己会想办法有效地利用CPU的寄存器，所以现在register关键字也用得比较少了。
- extern，上面讲过，链接属性是根据一个标识符多次声明时是不是代表同一个变量或函数来分类的，extern关键字就用于多次声明同一个标识符。
- typedef，它并不是用来修饰变量的，而是定义一个类型名。在那一节也讲过，看typedef声明怎么看呢，首先去掉typedef把它看成变量声明，看这个变量是什么类型的，那么typedef就定义了一个什么类型，也就是说，typedef在语法结构中出现的位置和是面几个关键字一样，也是修饰变量定义的，所以从语法（而不是语义）的角度把它和前面几个关键字归类到一起。

注意，上面介绍的const关键字不是一个**Storage Class Specifier**，虽然看起来它也修饰一个变量声明，但是在以后介绍的更复杂的声明中const在语法结构中允许出现的位置和**Storage ClassSpecifier**是不完全相同的。const和以后要介绍的restrict和volatile关键字属于同一类语法元素，称为类型限定符（Type Qualifier）。

变量的生存期（**Storage Duration**，或者**Lifetime**）分为以下几类：

- 静态生存期（**Static Storage Duration**），具有外部或内部链接属性，或者被static修饰的变量，在程序开始执行时分配和初始化一次，此后便一直存在直到程序结束。这种变量通常位于.rodata，.data或.bss段，例如上例中main函数外的A，a，b，c，以及main函数里的a。
- 自动生存期（**Automatic Storage Duration**），链接属性为无链接并且没有被static修饰的变量，这种变量在进入块作用域时在栈上或寄存器中分配，在退出块作用域时释放。例如上例中main函数里的b和c。
- 动态分配生存期（**Allocated Storage Duration**），以后会讲到调用malloc函数在进程的堆空间中分配内存，调用free函数可以释放这种存储空间。

## 结构体和联合体

```C
#include <stdio.h>
int main(int argc, char **argv)
{
    struct
    {
        char a;
        short b;
        int c;
        char d;
    } s;
    s.a = 1;
    s.b = 2;
    s.c = 3;
    s.d = 4;
    printf("%u\n", sizeof(s));
    return 0;
}
```

虽然栈是从高地址向低地址增长的，但结构体成员也是从低地址向高地址排列的，这一点和数组类似。但有一点和数组不同，结构体的各成员并不是一个紧挨一个排列的，中间有空隙，称为填充（**Padding**），不仅如此，在这个结构体的末尾也有三个字节的填充，所以**sizeof(s)**的值是12。注意，**printf**的%u转换说明表示无符号数，**sizeof**的值是size_t类型的，是某种无符号整型。

大多数计算机体系统结构对于访问内存的指令是有限制的，在32位平台上，访问4字节的指令（比如上面的movl）所访问的内存地址应该是4的整数倍，访问两字节的指令（比如上面的**movw**）所访问的内存地址应该是两字节的整数倍，这称为对齐（**Alignment**）。如果指令所访问的内存地址没有正确对齐会怎么样呢？在有些平台上将不能访问内存，而是引发一个异常，在**x86**平台上倒是仍然能访问内存，但是不对齐的指令执行效率比对齐的指令要低，所以编译器在安排各种变量的地址时都会考虑到对齐的问题。对于本例中的结构体，编译器会把它的基地址对齐到**4**字节边界，也就是说，**ebp-0x10**这个地址一定是4的整数倍。**s.a**占一个字节，没有对齐的问题。**s.b**占两个字节，如果**s.b**紧挨在**s.a**后面，它的地址就不能是两字节的整数倍了，所以编译器会在结构体中插入一个填充字节，使**s.b**的地址也是两字节的整数倍。**s.c**占4字节，紧挨在**s.b**的后面就可以了，因为**ebp-0xc**这个地址也是**4**的整数倍。那么为什么**s.d**的后面也要有填充位填充到4字节边界呢？这是为了便于安排这个结构体后面的变量的地址，假如用这种结构体类型组成一个数组，那么后一个结构体只需和前一个结构体紧挨着排列就可以保证它的基地址仍然对齐到4字节边界了，因为在前一个结构体的末尾已经有了填充字节。事实上，C标准规定数组元素必须紧挨着排列，不能有空隙，这样才能保证每个元素的地址可以按“**基地址+n×元素大小**”简单计算出来。

合理设计结构体各成员的排列顺序可以节省存储空间,上例中的结构体改成这样就可以避免产生填充字节

```c
struct { 
    char a; 
    char d; 
    short b; 
    int c;
} s;
```

此外，gcc提供了一种扩展语法可以消除结构体中的填充字节：

```c
struct { 
    char a;
	short b; 
    int c; 
    char d;
} __attribute__((packed)) s;
```

这样就不能保证结构体成员的对齐了，在访问b和c的时候可能会有效率问题，所以除非有特别的理由，一般不要使用这种语法。

在结构体中还可以使用Bit Field语法定义只占几个Bit的成员

## 链接详解

### 多目标文件的链接

一步编译

```shell
gcc main.c stack.c -o main
```

也可多步编译

```shell
gcc -c main.c
gcc -c stack.c 
gcc main.o stack.o -o main
```

文件的先后导致编译的先后，导致可执行文件内的先后

### 定义和声明

#### extern和static关键字

##### extern

extern置于**变量或者函数**前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。此外extern也可用来进行链接指定.

extern有两个作用，第一个,当它与"C"一起连用时，如: extern "C" void fun(int a, int b);则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的，C++的规则在翻译这个函数名时会把fun这个名字变得面目全非，可能是fun@aBc_int_int#%$也可能是别的，这要看编译器的"脾气"了(不同的编译器采用的方法不一样)，为什么这么做呢，因为C++支持函数的重载啊，在这里不去过多的论述这个问题，如果你有兴趣可以去网上搜索，相信你可以得到满意的解释!
  	第二，当extern不与"C"在一起修饰变量或函数时，如在头文件中: extern int g_Int; 它的作用就是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块或其他模块中使用，记住它是一个声明不是定义!也就是说B模块(编译单元)要是引用模块(编译单元)A中定义的全局变量或函数时，它只要包含A模块的头文件即可,在编译阶段，模块B虽然找不到该函数或变量，但它不会报错，它会在连接时从模块A生成的目标代码中找到此函数。

##### static

三种作用，隐藏，保持变量内容的持久，默认初始化为 0

当同时编译多个文件时，所有未加 static 前缀的全局变量和函数都具有全局可见性。static 可以用作函数和变量的前缀，对于函数来讲，static 的作用仅限于隐藏，而对于变量，static 还有下面两个作用。

存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和 static 变量，只不过和全局变量比起来，static 可以控制变量的可见范围，说到底 static 还是用来隐藏的。

在静态数据区，内存中所有的字节默认值都是 **0x00**，某些时候这一特点可以减少程序员的工作量。比如初始化一个稀疏矩阵，我们可以一个一个地把所有元素都置 **0**，然后把不是 **0** 的几个元素赋值。如果定义成静态的，就省去了一开始置 **0** 的操作。再比如要把一个字符数组当字符串来用，但又觉得每次在字符数组末尾加 **\0** 太麻烦。如果把字符串定义成静态的，就省去了这个麻烦，因为那里本来就是 **\0** 。

#### 头文件 

当编译时，编译器会自动寻找当前目录下自定义的.h头文件

实例：

```c
//a.c
#include "b.h"
#include <stdio.h>
int main()
{
    int a = 1, b = 2;
    printf("%d", sum(a, b));
}
```

```c
//b.c
int sum(int a,int b)
{
    return a + b;
}
```

```c
//b.h
#ifndef B_H
#define B_H
extern int sum(int, int);
#endif
```

编译时使用

```shell
gcc a.c b.c -o a.out
```

如果头文件不在当前目录下 gcc 可以使用 -I 选项写路径，或者在#include时写路径

b.h里使用了两个预处理指示**#ifndef B_H**和**#endif**，意思是说，如果**B_H**这个宏没有定义过，那么从**#ifndef**到**#endif**之间的代码就包含在预处理的输出结果中，否则这一段代码就不出现在预处理的输出结果中。可以防止#include 重复调用这个头文件

### 静态库

