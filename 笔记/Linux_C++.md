# 基础

##  1 命名空间

### 1.1 名称空间的定义

基本格式

```c++
namespace 名称空间名
{
    int a;
    int add(int,int);
}
```

- 定义在名称空间中的变量或者函数都称为实体
- 名称空间中的实体作用域是全局的, 并不意味着其可见域是全局的
- 如果不使用作用域限定符和using机制，抛开名称空间嵌套和内部屏蔽的情况，实体的可见域是从实体创建到该名称空间结束
- 在名称空间外，该实体是不可见的

### 1.2 名称空间的使用方式

#### 1.2.1 作用限定符

在某个名称空间中定义或创建的程序实体，如果要在其他名称空间中或外部函数中访问，可以使用作用域限定符来使实体可见，如：

```c++
std::cout <<  1 << std::endl;
```

#### 1.2.2 using声明机制

- 如果不希望在每次使用名称空间中实体时都使用作用域限定符，可使用using声明机制扩展其可见域，using声明的基本格式为：

  ```c++
  using 名称空间::实体名;
  ```

- 如“using A::dispA;”，至于using声明语句将该实体的可见域扩展到什么程度，这取决于using语句的书写位置，换言之，这取决于using语句的可见域。

#### 1.2.3 using声明机制二义性

- 如果using声明使用不当，很容易引起多重声明错误，比如:
  已经定义了全局函数disp，却还使用全局using声明语句“using A::disp”，假设没有屏蔽发生，那么调用disp()时，编译器不确定是全局函数版本还是A::disp()，引发多重声明错误。

- 变量名同样存在这种问题
  假设有两个名称空间A、B中都定义了int型变量num，在程序的某处需要使用num，如果写出如下代码：

  using A::num;
  using B::num;
  num=5;

#### 1.2.4 using编译指令

using声明机制使得某个空间中的特定实体可见，using编译指令比using声明更进一步，通过      “using namespace 名称空间名;”的形式，使得名称空间中的所有实体都可见，不再需要作用域限定符。如

```c++
using namespace std;
```

### 1.3 名称空间的作用域和可见域

- 原则上讲，名称空间的作用域是全局的，但其可见域却并非如此，而且，不论使用限定符还是使用using声明语句，都要求名称空间可见
- 回头看以下前面给出的代码，如果将namespace B的定义放在namespace A定义之后，编译器将指出错误，using语句同样如此，如果在using声明时，namespace尚未定义，或者说namespace已经定义，但声明的实体尚未包含在此namespace中，编译器同样会指出错误，
- 因此，名称空间同样要先定义、后使用。

#### 1.3.1 名称空间的定义策略

- 假设想实现如下功能：A::dispA函数中要访问B::num，这要求B定义在A前；同时，在B中增加dispB函数，其中调用A::dispA()函数，这要求A定义在B之前，如此看来，上述功能似乎不太可能会实现。
- 实则不然，这取决于名称空间的定义策略，在前面提及，名称空间中函数的定义和实现可以分开进行，这是我们解决问题的突破口
- 另外，函数原型可以多次声明

1.3.2 名称空间嵌套

- 名称空间可以定义在另一个名称空间内，以单层嵌套为例，要访问内部名称空间中的实体，必须采用“外部名称空间::内部名称空间::实体名”的形式，如果是多层嵌套，还要多次使用作用域限定符。

1.3.3 匿名的名称空间

- 也可以通过省略名称空间的名称来创建匿名的名称空间，此时，该无名空间中的实体的可见性无法扩展（既不能采用“名称空间::实体”的形式，也不能采用using声明机制扩展），因此，该实体只能在本空间内使用。
- 在匿名空间中创建的全局变量，具有全局生存期，却只能被本空间内的函数等访问，是static变量的有效替代手段。

### 小结

作用域限定符::、using声明机制和using编译机制是3种常用的扩展实体可见域的方式，使名称空间中的特定实体或全部实体在声明可见域内可用。名称空间内实体的访问规则和原来介绍的没有名称空间时的情况类似，名称空间还支持嵌套层次结构，在外部使用内层空间时，必须使用多重作用域限定符的形式。

下面引用当前流行的名称空间使用指导原则：

1. 提倡在已命名的名称空间中定义变量，而不是直接定义外部全局变量或者静态全局变量。
2. 如果开发了一个函数库或者类库，提倡将其放在一个名称空间中。
3. 对于using 声明，首先将其作用域设置为局部而不是全局
4. 不要在头文件中使用using编译指令，这样，使得可用名称变得模糊，容易出现二义性，其次，包含头文件的顺序可能会影响程序的行为，如果非要使用using编译指令，建议放在所有#include预编译指令后。

## 2 const 引用

### 2.1 const

#### 2.1.1 定义常量

```c++
const int MAX_VAL=22;
int const MIN_VAL=0;
const int kMax=100;
```

常量必须进行初始化

2.1.2 定义指向常量的指针（常量指针）

